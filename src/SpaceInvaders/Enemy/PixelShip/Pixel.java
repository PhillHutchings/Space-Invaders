/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package SpaceInvaders.Enemy.PixelShip;

import Ship.SpaceShip;
import SpaceInvaders.Sprite;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 *
 * @author hutch
 */
public class Pixel extends Sprite{

    private final String getImage;
    private Image shield;
    private boolean center;
    
    public Pixel(SpaceShip ss, int x, int y, int width, int height) {
       
        super(ss, x, y, width, height);
        getImage = findCenterPixel(x,y) ? "/PixelShip/pixelShipCenter.png" : "/PixelShip/pixelShip.png";
        init();
    }
     
    private void init(){
        
        if(isCenter()){
            
            loadAttackshield();
        }
        loadImage(getImage);
        setHealth("Horizontal", 50, 50, 100, 20, 400, 5, Color.BLACK, Color.ORANGE);
    }
    
    /**
     * loads shield image foe centre pixel
     */
    
    private void loadAttackshield(){
        
        try {
            
            BufferedImage buff = ImageIO.read(getClass().getResourceAsStream("/SpaceInvaders/Enemy/PixelShip/pixelShield.png"));
            ImageIcon ii = new ImageIcon(buff);
            shield = ii.getImage().getScaledInstance(getWidth() * 20, getHeight() * 20, Image.SCALE_SMOOTH);
            
        } catch (IOException ex) {
            
            Logger.getLogger(Pixel.class.getName()).log(Level.SEVERE, null, ex);
        }    
    }
   
    public void drawPixelShip(Graphics2D g){
        
        if(!isDestroyed()){
            
           g.drawImage(getImage(), getPosX(), getPosY(), null);
           
           if(isCenter()){
               
               g.drawImage(shield, getPosX() + (getWidth() / 2) - (shield.getWidth(null) / 2), getPosY() - (getHeight() / 2) - (shield.getHeight(null) / 2) + 15,  null);
           }
          // move();
           
        }
    }
        
    private void move(){
            
        //bounces off edges like ball in pong
        
        if(y + moveY <= 0){
            
            moveY = 1;
        }
        
        if(y + moveY >= BOARD_HEIGHT - height){
            
            moveY = -1;
        }
        
        if(x + moveX <= 0){
            
            moveX = 1;
        }
        
        if(x + moveX >= BOARD_WIDTH - width){
            
            moveX = -1;
        }
        
        x = x + moveX;
        y = y + moveY;
        
        posX = x;
        posY = y;
        
    }
   
    /**
     * find the centre pixel to draw the shield
     * @param cenX
     * @param cenY
     * @return 
     */
    
    private boolean findCenterPixel(int cenX, int cenY){
        
        if(cenX == (BOARD_WIDTH / 2) - (getWidth() / 2) && cenY == -200 + (getHeight() * 3)){  //location of center pixel the shield generator
            
            center = true;
        }
        
        return center;
    }

    public boolean isCenter() {
        
        return center;
    }
    
    
    /**
     * area of proximity that player will be attacked
     * @return 
     */

    public Rectangle getAttackBounds(){
        
       return new Rectangle(getPosX() - getWidth(), getPosY() - getHeight(), getWidth() * 6, getHeight() * 6);
       
    }
    
    /**
     * get bounds of the shield generated by the centre pixel
     * @return 
     */
    
    public Rectangle getShieldBounds(){
        
        return new Rectangle(getPosX() + (getWidth() / 2) - (shield.getWidth(null) / 2), getPosY() - (getHeight() / 2) - (shield.getHeight(null) / 2) + 15, shield.getWidth(null), shield.getHeight(null));
    }
    
}
